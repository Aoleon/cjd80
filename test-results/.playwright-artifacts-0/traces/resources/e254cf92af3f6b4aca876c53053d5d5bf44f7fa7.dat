import { OfflineQueue } from "/src/lib/offline-queue.ts";
const MAX_RETRY_COUNT = 3;
async function throwIfResNotOk(res) {
  if (!res.ok) {
    const text = await res.text() || res.statusText;
    throw new Error(`${res.status}: ${text}`);
  }
}
export function isOnline() {
  return navigator.onLine;
}
function getActionType(endpoint, method) {
  if (endpoint.includes("/api/votes")) return "VOTE_IDEA";
  if (endpoint.includes("/api/inscriptions")) return "SUBSCRIBE_EVENT";
  if (endpoint.includes("/api/events") && endpoint.includes("/subscribe")) return "SUBSCRIBE_EVENT";
  if (endpoint.includes("/api/unsubscriptions")) return "UNSUBSCRIBE_EVENT";
  if (endpoint.includes("/api/events") && endpoint.includes("/unsubscribe")) return "UNSUBSCRIBE_EVENT";
  if (endpoint.includes("/comments")) return "COMMENT";
  return "VOTE_IDEA";
}
function generateMockedData(actionType, endpoint, requestData) {
  const timestamp = Date.now();
  const pendingId = `pending-${timestamp}`;
  switch (actionType) {
    case "VOTE_IDEA":
      return {
        id: pendingId,
        ideaId: requestData?.ideaId,
        voterName: requestData?.voterName,
        voterEmail: requestData?.voterEmail,
        votedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
    case "SUBSCRIBE_EVENT":
      return {
        id: pendingId,
        eventId: requestData?.eventId,
        name: requestData?.name,
        email: requestData?.email,
        company: requestData?.company,
        phone: requestData?.phone,
        registeredAt: (/* @__PURE__ */ new Date()).toISOString()
      };
    case "UNSUBSCRIBE_EVENT":
      return {
        id: pendingId,
        eventId: requestData?.eventId,
        name: requestData?.name,
        email: requestData?.email,
        unsubscribedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
    case "COMMENT":
      return {
        id: pendingId,
        content: requestData?.content,
        authorName: requestData?.authorName,
        authorEmail: requestData?.authorEmail,
        createdAt: (/* @__PURE__ */ new Date()).toISOString()
      };
    default:
      return {
        id: pendingId,
        ...typeof requestData === "object" && requestData !== null ? requestData : {}
      };
  }
}
async function registerBackgroundSync() {
  if ("serviceWorker" in navigator && "SyncManager" in window) {
    try {
      const registration = await navigator.serviceWorker.ready;
      await registration.sync.register("sync-queue");
      console.log("[SyncService] Background sync registered successfully");
    } catch (error) {
      console.error("[SyncService] Failed to register background sync:", error);
    }
  } else {
    console.warn("[SyncService] Background Sync API not supported");
  }
}
export async function wrapApiRequest(method, url, data) {
  if (isOnline()) {
    console.log("[SyncService] Online - making direct request to:", url);
    const res = await fetch(url, {
      method,
      headers: data ? { "Content-Type": "application/json" } : {},
      body: data ? JSON.stringify(data) : void 0,
      credentials: "include"
    });
    await throwIfResNotOk(res);
    return res;
  }
  const isMutation = ["POST", "PUT", "DELETE", "PATCH"].includes(method.toUpperCase());
  if (!isMutation) {
    console.log("[SyncService] Offline - attempting GET request:", url);
    const res = await fetch(url, {
      method,
      headers: data ? { "Content-Type": "application/json" } : {},
      body: data ? JSON.stringify(data) : void 0,
      credentials: "include"
    });
    await throwIfResNotOk(res);
    return res;
  }
  console.log("[SyncService] Offline - queuing mutation:", { method, url });
  try {
    const queue = OfflineQueue.getInstance();
    await queue.init();
    const actionType = getActionType(url, method);
    const actionId = await queue.addAction({
      type: actionType,
      endpoint: url,
      method: method.toUpperCase(),
      data
    });
    console.log("[SyncService] Action queued with ID:", actionId);
    console.warn(
      `⚠️ [SyncService] Action queued for offline sync!
   Type: ${actionType}
   Endpoint: ${url}
   Action ID: ${actionId}
   The action will be synchronized when connection is restored.`
    );
    await registerBackgroundSync();
    const mockedData = generateMockedData(actionType, url, data);
    const mockResponse = new Response(
      JSON.stringify({
        success: true,
        queued: true,
        message: "Action enregistrée - sera synchronisée quand la connexion reviendra",
        actionId,
        data: mockedData
      }),
      {
        status: 202,
        // Accepted - indicates queued for processing
        statusText: "Accepted - Queued for sync",
        headers: {
          "Content-Type": "application/json"
        }
      }
    );
    return mockResponse;
  } catch (error) {
    console.error("[SyncService] Failed to queue action:", error);
    const res = await fetch(url, {
      method,
      headers: data ? { "Content-Type": "application/json" } : {},
      body: data ? JSON.stringify(data) : void 0,
      credentials: "include"
    });
    await throwIfResNotOk(res);
    return res;
  }
}
export async function syncQueuedActions() {
  console.log("[SyncService] Starting sync of queued actions...");
  const queue = OfflineQueue.getInstance();
  await queue.init();
  const pendingActions = await queue.getByStatus("pending");
  if (pendingActions.length === 0) {
    console.log("[SyncService] No pending actions to sync");
    return { synced: 0, failed: 0 };
  }
  console.log(`[SyncService] Found ${pendingActions.length} pending actions to sync`);
  let syncedCount = 0;
  let failedCount = 0;
  for (const action of pendingActions) {
    try {
      await queue.updateStatus(action.id, "syncing");
      console.log(`[SyncService] Syncing action ${action.id}:`, action.type);
      const response = await fetch(action.endpoint, {
        method: action.method,
        headers: {
          "Content-Type": "application/json"
        },
        body: action.data ? JSON.stringify(action.data) : void 0,
        credentials: "include"
      });
      if (response.ok) {
        await queue.remove(action.id);
        syncedCount++;
        console.log(`[SyncService] ✓ Successfully synced action ${action.id}`);
      } else {
        const newRetryCount = (action.retryCount || 0) + 1;
        if (newRetryCount >= MAX_RETRY_COUNT) {
          await queue.updateStatus(action.id, "failed", newRetryCount);
          failedCount++;
          console.error(`[SyncService] ✗ Action ${action.id} failed after ${newRetryCount} attempts`);
        } else {
          await queue.updateStatus(action.id, "pending", newRetryCount);
          console.warn(`[SyncService] ⚠ Action ${action.id} failed (attempt ${newRetryCount}/${MAX_RETRY_COUNT})`);
        }
      }
    } catch (error) {
      const newRetryCount = (action.retryCount || 0) + 1;
      if (newRetryCount >= MAX_RETRY_COUNT) {
        await queue.updateStatus(action.id, "failed", newRetryCount);
        failedCount++;
        console.error(`[SyncService] ✗ Action ${action.id} error after ${newRetryCount} attempts:`, error);
      } else {
        await queue.updateStatus(action.id, "pending", newRetryCount);
        console.warn(`[SyncService] ⚠ Action ${action.id} error (attempt ${newRetryCount}/${MAX_RETRY_COUNT}):`, error);
      }
    }
  }
  console.log(`[SyncService] Sync complete: ${syncedCount} synced, ${failedCount} failed`);
  return { synced: syncedCount, failed: failedCount };
}
export function initSyncService() {
  window.addEventListener("online", async () => {
    console.log("[SyncService] Connection restored - triggering sync...");
    try {
      const result = await syncQueuedActions();
      if (result.synced > 0) {
        console.log(`[SyncService] Successfully synchronized ${result.synced} action(s)`);
        window.dispatchEvent(new CustomEvent("sync-complete", {
          detail: { synced: result.synced, failed: result.failed }
        }));
      }
      if (result.failed > 0) {
        console.error(`[SyncService] Failed to sync ${result.failed} action(s)`);
        window.dispatchEvent(new CustomEvent("sync-failed", {
          detail: { failed: result.failed }
        }));
      }
    } catch (error) {
      console.error("[SyncService] Error during sync:", error);
    }
  });
  console.log("[SyncService] Initialized - listening for online events");
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInN5bmMtc2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFN5bmMgU2VydmljZSAtIEF1dG9tYXRpYyBzeW5jaHJvbml6YXRpb24gd2l0aCBCYWNrZ3JvdW5kIFN5bmMgQVBJXG4gKiBIYW5kbGVzIG9mZmxpbmUgYWN0aW9ucyBhbmQgc3luY3MgdGhlbSB3aGVuIGNvbm5lY3Rpb24gaXMgcmVzdG9yZWRcbiAqL1xuXG5pbXBvcnQgeyBPZmZsaW5lUXVldWUsIHR5cGUgUXVldWVBY3Rpb24sIHR5cGUgQWN0aW9uVHlwZSB9IGZyb20gJy4vb2ZmbGluZS1xdWV1ZSc7XG5cbi8vIFR5cGUgZGVjbGFyYXRpb24gZm9yIEJhY2tncm91bmQgU3luYyBBUEkgKGRlY2xhcmF0aW9uIG1lcmdpbmcpXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBTeW5jTWFuYWdlciB7XG4gICAgcmVnaXN0ZXIodGFnOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xuICAgIGdldFRhZ3MoKTogUHJvbWlzZTxzdHJpbmdbXT47XG4gIH1cblxuICBpbnRlcmZhY2UgU2VydmljZVdvcmtlclJlZ2lzdHJhdGlvbiB7XG4gICAgcmVhZG9ubHkgc3luYzogU3luY01hbmFnZXI7XG4gIH1cbn1cblxuY29uc3QgTUFYX1JFVFJZX0NPVU5UID0gMztcblxuLyoqXG4gKiBUaHJvdyBlcnJvciBpZiByZXNwb25zZSBpcyBub3Qgb2tcbiAqIExvY2FsIGhlbHBlciBmdW5jdGlvbiB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5IHdpdGggcXVlcnlDbGllbnRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdGhyb3dJZlJlc05vdE9rKHJlczogUmVzcG9uc2UpIHtcbiAgaWYgKCFyZXMub2spIHtcbiAgICBjb25zdCB0ZXh0ID0gKGF3YWl0IHJlcy50ZXh0KCkpIHx8IHJlcy5zdGF0dXNUZXh0O1xuICAgIHRocm93IG5ldyBFcnJvcihgJHtyZXMuc3RhdHVzfTogJHt0ZXh0fWApO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdXNlciBpcyBvbmxpbmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT25saW5lKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gbmF2aWdhdG9yLm9uTGluZTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgYWN0aW9uIHR5cGUgYmFzZWQgb24gZW5kcG9pbnQgYW5kIG1ldGhvZFxuICogTWFwcyBBUEkgZW5kcG9pbnRzIHRvIG9mZmxpbmUgYWN0aW9uIHR5cGVzIGZvciBwcm9wZXIgcXVldWUgbWFuYWdlbWVudFxuICovXG5mdW5jdGlvbiBnZXRBY3Rpb25UeXBlKGVuZHBvaW50OiBzdHJpbmcsIG1ldGhvZDogc3RyaW5nKTogQWN0aW9uVHlwZSB7XG4gIC8vIFZvdGUgZW5kcG9pbnRzXG4gIGlmIChlbmRwb2ludC5pbmNsdWRlcygnL2FwaS92b3RlcycpKSByZXR1cm4gJ1ZPVEVfSURFQSc7XG4gIFxuICAvLyBFdmVudCBzdWJzY3JpcHRpb24gZW5kcG9pbnRzXG4gIGlmIChlbmRwb2ludC5pbmNsdWRlcygnL2FwaS9pbnNjcmlwdGlvbnMnKSkgcmV0dXJuICdTVUJTQ1JJQkVfRVZFTlQnO1xuICBpZiAoZW5kcG9pbnQuaW5jbHVkZXMoJy9hcGkvZXZlbnRzJykgJiYgZW5kcG9pbnQuaW5jbHVkZXMoJy9zdWJzY3JpYmUnKSkgcmV0dXJuICdTVUJTQ1JJQkVfRVZFTlQnO1xuICBcbiAgLy8gRXZlbnQgdW5zdWJzY3JpcHRpb24gZW5kcG9pbnRzXG4gIGlmIChlbmRwb2ludC5pbmNsdWRlcygnL2FwaS91bnN1YnNjcmlwdGlvbnMnKSkgcmV0dXJuICdVTlNVQlNDUklCRV9FVkVOVCc7XG4gIGlmIChlbmRwb2ludC5pbmNsdWRlcygnL2FwaS9ldmVudHMnKSAmJiBlbmRwb2ludC5pbmNsdWRlcygnL3Vuc3Vic2NyaWJlJykpIHJldHVybiAnVU5TVUJTQ1JJQkVfRVZFTlQnO1xuICBcbiAgLy8gQ29tbWVudCBlbmRwb2ludHMgKGJvdGggL2FwaS9jb21tZW50cyBhbmQgbmVzdGVkIGxpa2UgL2FwaS9pZGVhcy8qL2NvbW1lbnRzKVxuICBpZiAoZW5kcG9pbnQuaW5jbHVkZXMoJy9jb21tZW50cycpKSByZXR1cm4gJ0NPTU1FTlQnO1xuICBcbiAgLy8gRGVmYXVsdCB0byBWT1RFX0lERUEgZm9yIG90aGVyIG11dGF0aW9uc1xuICByZXR1cm4gJ1ZPVEVfSURFQSc7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgbW9ja2VkIHJlc3BvbnNlIGRhdGEgYmFzZWQgb24gYWN0aW9uIHR5cGVcbiAqIFRoaXMgZW5zdXJlcyB0aGUgVUkgcmVjZWl2ZXMgZGF0YSBpbiB0aGUgZXhwZWN0ZWQgZm9ybWF0IHdoZW4gYWN0aW9ucyBhcmUgcXVldWVkIG9mZmxpbmVcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVNb2NrZWREYXRhKGFjdGlvblR5cGU6IEFjdGlvblR5cGUsIGVuZHBvaW50OiBzdHJpbmcsIHJlcXVlc3REYXRhPzogdW5rbm93bik6IGFueSB7XG4gIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gIGNvbnN0IHBlbmRpbmdJZCA9IGBwZW5kaW5nLSR7dGltZXN0YW1wfWA7XG4gIFxuICBzd2l0Y2ggKGFjdGlvblR5cGUpIHtcbiAgICBjYXNlICdWT1RFX0lERUEnOlxuICAgICAgLy8gTW9ja2VkIHZvdGUgcmVzcG9uc2UgLSBtYXRjaGVzIGJhY2tlbmQgZm9ybWF0XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogcGVuZGluZ0lkLFxuICAgICAgICBpZGVhSWQ6IChyZXF1ZXN0RGF0YSBhcyBhbnkpPy5pZGVhSWQsXG4gICAgICAgIHZvdGVyTmFtZTogKHJlcXVlc3REYXRhIGFzIGFueSk/LnZvdGVyTmFtZSxcbiAgICAgICAgdm90ZXJFbWFpbDogKHJlcXVlc3REYXRhIGFzIGFueSk/LnZvdGVyRW1haWwsXG4gICAgICAgIHZvdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH07XG4gICAgXG4gICAgY2FzZSAnU1VCU0NSSUJFX0VWRU5UJzpcbiAgICAgIC8vIE1vY2tlZCBpbnNjcmlwdGlvbiByZXNwb25zZSAtIG1hdGNoZXMgYmFja2VuZCBmb3JtYXRcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBwZW5kaW5nSWQsXG4gICAgICAgIGV2ZW50SWQ6IChyZXF1ZXN0RGF0YSBhcyBhbnkpPy5ldmVudElkLFxuICAgICAgICBuYW1lOiAocmVxdWVzdERhdGEgYXMgYW55KT8ubmFtZSxcbiAgICAgICAgZW1haWw6IChyZXF1ZXN0RGF0YSBhcyBhbnkpPy5lbWFpbCxcbiAgICAgICAgY29tcGFueTogKHJlcXVlc3REYXRhIGFzIGFueSk/LmNvbXBhbnksXG4gICAgICAgIHBob25lOiAocmVxdWVzdERhdGEgYXMgYW55KT8ucGhvbmUsXG4gICAgICAgIHJlZ2lzdGVyZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfTtcbiAgICBcbiAgICBjYXNlICdVTlNVQlNDUklCRV9FVkVOVCc6XG4gICAgICAvLyBNb2NrZWQgdW5zdWJzY3JpcHRpb24gcmVzcG9uc2UgLSBtYXRjaGVzIGJhY2tlbmQgZm9ybWF0XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogcGVuZGluZ0lkLFxuICAgICAgICBldmVudElkOiAocmVxdWVzdERhdGEgYXMgYW55KT8uZXZlbnRJZCxcbiAgICAgICAgbmFtZTogKHJlcXVlc3REYXRhIGFzIGFueSk/Lm5hbWUsXG4gICAgICAgIGVtYWlsOiAocmVxdWVzdERhdGEgYXMgYW55KT8uZW1haWwsXG4gICAgICAgIHVuc3Vic2NyaWJlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9O1xuICAgIFxuICAgIGNhc2UgJ0NPTU1FTlQnOlxuICAgICAgLy8gTW9ja2VkIGNvbW1lbnQgcmVzcG9uc2UgLSBtYXRjaGVzIGJhY2tlbmQgZm9ybWF0XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogcGVuZGluZ0lkLFxuICAgICAgICBjb250ZW50OiAocmVxdWVzdERhdGEgYXMgYW55KT8uY29udGVudCxcbiAgICAgICAgYXV0aG9yTmFtZTogKHJlcXVlc3REYXRhIGFzIGFueSk/LmF1dGhvck5hbWUsXG4gICAgICAgIGF1dGhvckVtYWlsOiAocmVxdWVzdERhdGEgYXMgYW55KT8uYXV0aG9yRW1haWwsXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfTtcbiAgICBcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gR2VuZXJpYyBtb2NrZWQgcmVzcG9uc2VcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBwZW5kaW5nSWQsXG4gICAgICAgIC4uLih0eXBlb2YgcmVxdWVzdERhdGEgPT09ICdvYmplY3QnICYmIHJlcXVlc3REYXRhICE9PSBudWxsID8gcmVxdWVzdERhdGEgOiB7fSksXG4gICAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUmVnaXN0ZXIgYmFja2dyb3VuZCBzeW5jIHdpdGggU2VydmljZSBXb3JrZXJcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVnaXN0ZXJCYWNrZ3JvdW5kU3luYygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgaWYgKCdzZXJ2aWNlV29ya2VyJyBpbiBuYXZpZ2F0b3IgJiYgJ1N5bmNNYW5hZ2VyJyBpbiB3aW5kb3cpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVnaXN0cmF0aW9uID0gYXdhaXQgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIucmVhZHk7XG4gICAgICBhd2FpdCByZWdpc3RyYXRpb24uc3luYy5yZWdpc3Rlcignc3luYy1xdWV1ZScpO1xuICAgICAgY29uc29sZS5sb2coJ1tTeW5jU2VydmljZV0gQmFja2dyb3VuZCBzeW5jIHJlZ2lzdGVyZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTeW5jU2VydmljZV0gRmFpbGVkIHRvIHJlZ2lzdGVyIGJhY2tncm91bmQgc3luYzonLCBlcnJvcik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUud2FybignW1N5bmNTZXJ2aWNlXSBCYWNrZ3JvdW5kIFN5bmMgQVBJIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxufVxuXG4vKipcbiAqIFdyYXAgQVBJIHJlcXVlc3Qgd2l0aCBvZmZsaW5lIHN1cHBvcnRcbiAqIEludGVyY2VwdHMgcmVxdWVzdHMgd2hlbiBvZmZsaW5lIGFuZCBxdWV1ZXMgdGhlbSBmb3IgbGF0ZXIgc3luY1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd3JhcEFwaVJlcXVlc3QoXG4gIG1ldGhvZDogc3RyaW5nLFxuICB1cmw6IHN0cmluZyxcbiAgZGF0YT86IHVua25vd24gfCB1bmRlZmluZWQsXG4pOiBQcm9taXNlPFJlc3BvbnNlPiB7XG4gIC8vIElmIG9ubGluZSwgbWFrZSBub3JtYWwgcmVxdWVzdFxuICBpZiAoaXNPbmxpbmUoKSkge1xuICAgIGNvbnNvbGUubG9nKCdbU3luY1NlcnZpY2VdIE9ubGluZSAtIG1ha2luZyBkaXJlY3QgcmVxdWVzdCB0bzonLCB1cmwpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgbWV0aG9kLFxuICAgICAgaGVhZGVyczogZGF0YSA/IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSA6IHt9LFxuICAgICAgYm9keTogZGF0YSA/IEpTT04uc3RyaW5naWZ5KGRhdGEpIDogdW5kZWZpbmVkLFxuICAgICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiLFxuICAgIH0pO1xuICAgIGF3YWl0IHRocm93SWZSZXNOb3RPayhyZXMpO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgbXV0YXRpb24gKFBPU1QvUFVUL0RFTEVURSlcbiAgY29uc3QgaXNNdXRhdGlvbiA9IFsnUE9TVCcsICdQVVQnLCAnREVMRVRFJywgJ1BBVENIJ10uaW5jbHVkZXMobWV0aG9kLnRvVXBwZXJDYXNlKCkpO1xuICBcbiAgaWYgKCFpc011dGF0aW9uKSB7XG4gICAgLy8gRm9yIEdFVCByZXF1ZXN0cyB3aGVuIG9mZmxpbmUsIHRyeSB0byBwcm9jZWVkICh3aWxsIGZhaWwgbmF0dXJhbGx5KVxuICAgIGNvbnNvbGUubG9nKCdbU3luY1NlcnZpY2VdIE9mZmxpbmUgLSBhdHRlbXB0aW5nIEdFVCByZXF1ZXN0OicsIHVybCk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICBtZXRob2QsXG4gICAgICBoZWFkZXJzOiBkYXRhID8geyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9IDoge30sXG4gICAgICBib2R5OiBkYXRhID8gSlNPTi5zdHJpbmdpZnkoZGF0YSkgOiB1bmRlZmluZWQsXG4gICAgICBjcmVkZW50aWFsczogXCJpbmNsdWRlXCIsXG4gICAgfSk7XG4gICAgYXdhaXQgdGhyb3dJZlJlc05vdE9rKHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8vIE9mZmxpbmUgbXV0YXRpb24gLSBxdWV1ZSB0aGUgYWN0aW9uXG4gIGNvbnNvbGUubG9nKCdbU3luY1NlcnZpY2VdIE9mZmxpbmUgLSBxdWV1aW5nIG11dGF0aW9uOicsIHsgbWV0aG9kLCB1cmwgfSk7XG4gIFxuICB0cnkge1xuICAgIGNvbnN0IHF1ZXVlID0gT2ZmbGluZVF1ZXVlLmdldEluc3RhbmNlKCk7XG4gICAgYXdhaXQgcXVldWUuaW5pdCgpO1xuICAgIFxuICAgIGNvbnN0IGFjdGlvblR5cGUgPSBnZXRBY3Rpb25UeXBlKHVybCwgbWV0aG9kKTtcbiAgICBcbiAgICAvLyBBZGQgYWN0aW9uIHRvIHF1ZXVlXG4gICAgY29uc3QgYWN0aW9uSWQgPSBhd2FpdCBxdWV1ZS5hZGRBY3Rpb24oe1xuICAgICAgdHlwZTogYWN0aW9uVHlwZSxcbiAgICAgIGVuZHBvaW50OiB1cmwsXG4gICAgICBtZXRob2Q6IG1ldGhvZC50b1VwcGVyQ2FzZSgpIGFzICdQT1NUJyB8ICdQVVQnIHwgJ0RFTEVURScsXG4gICAgICBkYXRhLFxuICAgIH0pO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCdbU3luY1NlcnZpY2VdIEFjdGlvbiBxdWV1ZWQgd2l0aCBJRDonLCBhY3Rpb25JZCk7XG4gICAgXG4gICAgLy8gV0FSTklORzogQWN0aW9uIGhhcyBiZWVuIHF1ZXVlZCBmb3IgbGF0ZXIgc3luY2hyb25pemF0aW9uXG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYOKaoO+4jyBbU3luY1NlcnZpY2VdIEFjdGlvbiBxdWV1ZWQgZm9yIG9mZmxpbmUgc3luYyFcXG5gICtcbiAgICAgIGAgICBUeXBlOiAke2FjdGlvblR5cGV9XFxuYCArXG4gICAgICBgICAgRW5kcG9pbnQ6ICR7dXJsfVxcbmAgK1xuICAgICAgYCAgIEFjdGlvbiBJRDogJHthY3Rpb25JZH1cXG5gICtcbiAgICAgIGAgICBUaGUgYWN0aW9uIHdpbGwgYmUgc3luY2hyb25pemVkIHdoZW4gY29ubmVjdGlvbiBpcyByZXN0b3JlZC5gXG4gICAgKTtcbiAgICBcbiAgICAvLyBSZWdpc3RlciBiYWNrZ3JvdW5kIHN5bmNcbiAgICBhd2FpdCByZWdpc3RlckJhY2tncm91bmRTeW5jKCk7XG4gICAgXG4gICAgLy8gR2VuZXJhdGUgbW9ja2VkIGRhdGEgdGhhdCBtYXRjaGVzIGJhY2tlbmQgcmVzcG9uc2UgZm9ybWF0XG4gICAgY29uc3QgbW9ja2VkRGF0YSA9IGdlbmVyYXRlTW9ja2VkRGF0YShhY3Rpb25UeXBlLCB1cmwsIGRhdGEpO1xuICAgIFxuICAgIC8qKlxuICAgICAqIE1PQ0tFRCBSRVNQT05TRSBGT1JNQVQ6XG4gICAgICogVGhpcyByZXNwb25zZSBzaW11bGF0ZXMgYSBzdWNjZXNzZnVsIG11dGF0aW9uIHdoaWxlIG9mZmxpbmUuXG4gICAgICogLSBzdGF0dXM6IDIwMiAoQWNjZXB0ZWQpIGluZGljYXRlcyB0aGUgYWN0aW9uIGlzIHF1ZXVlZFxuICAgICAqIC0gcXVldWVkOiB0cnVlIGZsYWcgYWxsb3dzIFVJIHRvIGRldGVjdCBvZmZsaW5lIHN0YXRlXG4gICAgICogLSBkYXRhOiBDb250YWlucyBtb2NrZWQgZmllbGRzIG1hdGNoaW5nIGJhY2tlbmQgcmVzcG9uc2UgZm9ybWF0XG4gICAgICogXG4gICAgICogVGhlIFVJIGNhbiB1c2UgdGhpcyB0byB1cGRhdGUgb3B0aW1pc3RpY2FsbHkgd2hpbGUgd2FpdGluZyBmb3Igc3luYy5cbiAgICAgKi9cbiAgICBjb25zdCBtb2NrUmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoXG4gICAgICBKU09OLnN0cmluZ2lmeSh7IFxuICAgICAgICBzdWNjZXNzOiB0cnVlLCBcbiAgICAgICAgcXVldWVkOiB0cnVlLFxuICAgICAgICBtZXNzYWdlOiAnQWN0aW9uIGVucmVnaXN0csOpZSAtIHNlcmEgc3luY2hyb25pc8OpZSBxdWFuZCBsYSBjb25uZXhpb24gcmV2aWVuZHJhJyxcbiAgICAgICAgYWN0aW9uSWQsXG4gICAgICAgIGRhdGE6IG1vY2tlZERhdGFcbiAgICAgIH0pLFxuICAgICAge1xuICAgICAgICBzdGF0dXM6IDIwMiwgLy8gQWNjZXB0ZWQgLSBpbmRpY2F0ZXMgcXVldWVkIGZvciBwcm9jZXNzaW5nXG4gICAgICAgIHN0YXR1c1RleHQ6ICdBY2NlcHRlZCAtIFF1ZXVlZCBmb3Igc3luYycsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgfVxuICAgICk7XG4gICAgXG4gICAgcmV0dXJuIG1vY2tSZXNwb25zZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbU3luY1NlcnZpY2VdIEZhaWxlZCB0byBxdWV1ZSBhY3Rpb246JywgZXJyb3IpO1xuICAgIC8vIElmIHF1ZXVlaW5nIGZhaWxzLCB0cnkgdGhlIHJlcXVlc3QgYW55d2F5ICh3aWxsIGxpa2VseSBmYWlsIGJ1dCBtYWludGFpbnMgZXhwZWN0ZWQgYmVoYXZpb3IpXG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICBtZXRob2QsXG4gICAgICBoZWFkZXJzOiBkYXRhID8geyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9IDoge30sXG4gICAgICBib2R5OiBkYXRhID8gSlNPTi5zdHJpbmdpZnkoZGF0YSkgOiB1bmRlZmluZWQsXG4gICAgICBjcmVkZW50aWFsczogXCJpbmNsdWRlXCIsXG4gICAgfSk7XG4gICAgYXdhaXQgdGhyb3dJZlJlc05vdE9rKHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxufVxuXG4vKipcbiAqIFN5bmMgYWxsIHF1ZXVlZCBhY3Rpb25zXG4gKiBSZXR1cm5zIGNvdW50IG9mIHN1Y2Nlc3NmdWwgYW5kIGZhaWxlZCBzeW5jc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3luY1F1ZXVlZEFjdGlvbnMoKTogUHJvbWlzZTx7IHN5bmNlZDogbnVtYmVyOyBmYWlsZWQ6IG51bWJlciB9PiB7XG4gIGNvbnNvbGUubG9nKCdbU3luY1NlcnZpY2VdIFN0YXJ0aW5nIHN5bmMgb2YgcXVldWVkIGFjdGlvbnMuLi4nKTtcbiAgXG4gIGNvbnN0IHF1ZXVlID0gT2ZmbGluZVF1ZXVlLmdldEluc3RhbmNlKCk7XG4gIGF3YWl0IHF1ZXVlLmluaXQoKTtcbiAgXG4gIC8vIEdldCBhbGwgcGVuZGluZyBhY3Rpb25zXG4gIGNvbnN0IHBlbmRpbmdBY3Rpb25zID0gYXdhaXQgcXVldWUuZ2V0QnlTdGF0dXMoJ3BlbmRpbmcnKTtcbiAgXG4gIGlmIChwZW5kaW5nQWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICBjb25zb2xlLmxvZygnW1N5bmNTZXJ2aWNlXSBObyBwZW5kaW5nIGFjdGlvbnMgdG8gc3luYycpO1xuICAgIHJldHVybiB7IHN5bmNlZDogMCwgZmFpbGVkOiAwIH07XG4gIH1cbiAgXG4gIGNvbnNvbGUubG9nKGBbU3luY1NlcnZpY2VdIEZvdW5kICR7cGVuZGluZ0FjdGlvbnMubGVuZ3RofSBwZW5kaW5nIGFjdGlvbnMgdG8gc3luY2ApO1xuICBcbiAgbGV0IHN5bmNlZENvdW50ID0gMDtcbiAgbGV0IGZhaWxlZENvdW50ID0gMDtcbiAgXG4gIGZvciAoY29uc3QgYWN0aW9uIG9mIHBlbmRpbmdBY3Rpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIE1hcmsgYXMgc3luY2luZ1xuICAgICAgYXdhaXQgcXVldWUudXBkYXRlU3RhdHVzKGFjdGlvbi5pZCEsICdzeW5jaW5nJyk7XG4gICAgICBjb25zb2xlLmxvZyhgW1N5bmNTZXJ2aWNlXSBTeW5jaW5nIGFjdGlvbiAke2FjdGlvbi5pZH06YCwgYWN0aW9uLnR5cGUpO1xuICAgICAgXG4gICAgICAvLyBNYWtlIHRoZSBhY3R1YWwgQVBJIHJlcXVlc3RcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYWN0aW9uLmVuZHBvaW50LCB7XG4gICAgICAgIG1ldGhvZDogYWN0aW9uLm1ldGhvZCxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IGFjdGlvbi5kYXRhID8gSlNPTi5zdHJpbmdpZnkoYWN0aW9uLmRhdGEpIDogdW5kZWZpbmVkLFxuICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAvLyBTdWNjZXNzIC0gcmVtb3ZlIGZyb20gcXVldWVcbiAgICAgICAgYXdhaXQgcXVldWUucmVtb3ZlKGFjdGlvbi5pZCEpO1xuICAgICAgICBzeW5jZWRDb3VudCsrO1xuICAgICAgICBjb25zb2xlLmxvZyhgW1N5bmNTZXJ2aWNlXSDinJMgU3VjY2Vzc2Z1bGx5IHN5bmNlZCBhY3Rpb24gJHthY3Rpb24uaWR9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGYWlsZWQgLSBpbmNyZW1lbnQgcmV0cnkgY291bnRcbiAgICAgICAgY29uc3QgbmV3UmV0cnlDb3VudCA9IChhY3Rpb24ucmV0cnlDb3VudCB8fCAwKSArIDE7XG4gICAgICAgIFxuICAgICAgICBpZiAobmV3UmV0cnlDb3VudCA+PSBNQVhfUkVUUllfQ09VTlQpIHtcbiAgICAgICAgICAvLyBNYXggcmV0cmllcyByZWFjaGVkIC0gbWFyayBhcyBmYWlsZWRcbiAgICAgICAgICBhd2FpdCBxdWV1ZS51cGRhdGVTdGF0dXMoYWN0aW9uLmlkISwgJ2ZhaWxlZCcsIG5ld1JldHJ5Q291bnQpO1xuICAgICAgICAgIGZhaWxlZENvdW50Kys7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgW1N5bmNTZXJ2aWNlXSDinJcgQWN0aW9uICR7YWN0aW9uLmlkfSBmYWlsZWQgYWZ0ZXIgJHtuZXdSZXRyeUNvdW50fSBhdHRlbXB0c2ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE1hcmsgYmFjayBhcyBwZW5kaW5nIGZvciBuZXh0IHN5bmMgYXR0ZW1wdFxuICAgICAgICAgIGF3YWl0IHF1ZXVlLnVwZGF0ZVN0YXR1cyhhY3Rpb24uaWQhLCAncGVuZGluZycsIG5ld1JldHJ5Q291bnQpO1xuICAgICAgICAgIGNvbnNvbGUud2FybihgW1N5bmNTZXJ2aWNlXSDimqAgQWN0aW9uICR7YWN0aW9uLmlkfSBmYWlsZWQgKGF0dGVtcHQgJHtuZXdSZXRyeUNvdW50fS8ke01BWF9SRVRSWV9DT1VOVH0pYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gTmV0d29yayBvciBvdGhlciBlcnJvciAtIGluY3JlbWVudCByZXRyeSBjb3VudFxuICAgICAgY29uc3QgbmV3UmV0cnlDb3VudCA9IChhY3Rpb24ucmV0cnlDb3VudCB8fCAwKSArIDE7XG4gICAgICBcbiAgICAgIGlmIChuZXdSZXRyeUNvdW50ID49IE1BWF9SRVRSWV9DT1VOVCkge1xuICAgICAgICBhd2FpdCBxdWV1ZS51cGRhdGVTdGF0dXMoYWN0aW9uLmlkISwgJ2ZhaWxlZCcsIG5ld1JldHJ5Q291bnQpO1xuICAgICAgICBmYWlsZWRDb3VudCsrO1xuICAgICAgICBjb25zb2xlLmVycm9yKGBbU3luY1NlcnZpY2VdIOKclyBBY3Rpb24gJHthY3Rpb24uaWR9IGVycm9yIGFmdGVyICR7bmV3UmV0cnlDb3VudH0gYXR0ZW1wdHM6YCwgZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgcXVldWUudXBkYXRlU3RhdHVzKGFjdGlvbi5pZCEsICdwZW5kaW5nJywgbmV3UmV0cnlDb3VudCk7XG4gICAgICAgIGNvbnNvbGUud2FybihgW1N5bmNTZXJ2aWNlXSDimqAgQWN0aW9uICR7YWN0aW9uLmlkfSBlcnJvciAoYXR0ZW1wdCAke25ld1JldHJ5Q291bnR9LyR7TUFYX1JFVFJZX0NPVU5UfSk6YCwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgY29uc29sZS5sb2coYFtTeW5jU2VydmljZV0gU3luYyBjb21wbGV0ZTogJHtzeW5jZWRDb3VudH0gc3luY2VkLCAke2ZhaWxlZENvdW50fSBmYWlsZWRgKTtcbiAgcmV0dXJuIHsgc3luY2VkOiBzeW5jZWRDb3VudCwgZmFpbGVkOiBmYWlsZWRDb3VudCB9O1xufVxuXG4vKipcbiAqIEluaXRpYWxpemUgc3luYyBzZXJ2aWNlIHdpdGggb25saW5lIGV2ZW50IGxpc3RlbmVyXG4gKiBBdXRvbWF0aWNhbGx5IHN5bmNzIHF1ZXVlZCBhY3Rpb25zIHdoZW4gY29ubmVjdGlvbiBpcyByZXN0b3JlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdFN5bmNTZXJ2aWNlKCk6IHZvaWQge1xuICAvLyBMaXN0ZW4gZm9yIG9ubGluZSBldmVudFxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb25saW5lJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdbU3luY1NlcnZpY2VdIENvbm5lY3Rpb24gcmVzdG9yZWQgLSB0cmlnZ2VyaW5nIHN5bmMuLi4nKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3luY1F1ZXVlZEFjdGlvbnMoKTtcbiAgICAgIFxuICAgICAgaWYgKHJlc3VsdC5zeW5jZWQgPiAwKSB7XG4gICAgICAgIC8vIE5vdGlmeSB1c2VyIG9mIHN1Y2Nlc3NmdWwgc3luY1xuICAgICAgICBjb25zb2xlLmxvZyhgW1N5bmNTZXJ2aWNlXSBTdWNjZXNzZnVsbHkgc3luY2hyb25pemVkICR7cmVzdWx0LnN5bmNlZH0gYWN0aW9uKHMpYCk7XG4gICAgICAgIFxuICAgICAgICAvLyBEaXNwYXRjaCBjdXN0b20gZXZlbnQgZm9yIFVJIHRvIHNob3cgbm90aWZpY2F0aW9uXG4gICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnc3luYy1jb21wbGV0ZScsIHtcbiAgICAgICAgICBkZXRhaWw6IHsgc3luY2VkOiByZXN1bHQuc3luY2VkLCBmYWlsZWQ6IHJlc3VsdC5mYWlsZWQgfVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChyZXN1bHQuZmFpbGVkID4gMCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBbU3luY1NlcnZpY2VdIEZhaWxlZCB0byBzeW5jICR7cmVzdWx0LmZhaWxlZH0gYWN0aW9uKHMpYCk7XG4gICAgICAgIFxuICAgICAgICAvLyBEaXNwYXRjaCBjdXN0b20gZXZlbnQgZm9yIFVJIHRvIHNob3cgZXJyb3JcbiAgICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdzeW5jLWZhaWxlZCcsIHtcbiAgICAgICAgICBkZXRhaWw6IHsgZmFpbGVkOiByZXN1bHQuZmFpbGVkIH1cbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbU3luY1NlcnZpY2VdIEVycm9yIGR1cmluZyBzeW5jOicsIGVycm9yKTtcbiAgICB9XG4gIH0pO1xuICBcbiAgY29uc29sZS5sb2coJ1tTeW5jU2VydmljZV0gSW5pdGlhbGl6ZWQg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