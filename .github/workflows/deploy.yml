name: üöÄ Deploy Multi-Servers

on:
  push:
    branches:
      - main
    tags:
      - 'v*.*.*'  # Tags s√©mantiques (v1.0.0, v1.2.3, etc.)
  workflow_dispatch:
    inputs:
      server:
        description: 'Serveur sp√©cifique √† d√©ployer (laisser vide pour tous)'
        required: false
        type: choice
        options:
          - all
          - server1
          - server2
        default: all

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # ============================================================================
  # Job 1: Build & Push Docker Image (une seule fois)
  # ============================================================================
  build-and-push:
    name: üèóÔ∏è Build & Push Docker Image
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      contents: read
      packages: write
    
    outputs:
      image_tag: ${{ steps.image-tag.outputs.tag }}
      image_digest: ${{ steps.build.outputs.digest }}
      image_latest: ${{ steps.image-tag.outputs.latest }}
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
      
      - name: üîß Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
      
      - name: üì¶ Install dependencies
        run: npm ci --legacy-peer-deps || npm install --legacy-peer-deps
      
      - name: ‚úÖ Run type checks
        run: npm run check
      
      - name: üèóÔ∏è Run production build
        run: npm run build
      
      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            image=moby/buildkit:latest
      
      - name: üîê Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: üè∑Ô∏è Generate image tags
        id: image-tag
        run: |
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          
          # D√©tecter si c'est un push sur tag ou sur branche
          if [ "${{ github.event_name }}" = "push" ] && [ -n "${{ github.ref }}" ] && echo "${{ github.ref }}" | grep -q "refs/tags/"; then
            # C'est un tag Git - utiliser le nom du tag
            GIT_TAG=$(echo "${{ github.ref }}" | sed 's/refs\/tags\///')
            # Nettoyer le tag (enlever le pr√©fixe 'v' si pr√©sent pour le tag Docker)
            DOCKER_TAG=$(echo "$GIT_TAG" | sed 's/^v//')
            TAG="${{ env.REGISTRY }}/${REPO_LOWER}:${DOCKER_TAG}"
            # Garder aussi le tag avec 'v' pour compatibilit√©
            TAG_WITH_V="${{ env.REGISTRY }}/${REPO_LOWER}:${GIT_TAG}"
            LATEST_TAG="${{ env.REGISTRY }}/${REPO_LOWER}:latest"
            echo "tag=${TAG}" >> $GITHUB_OUTPUT
            echo "tag_with_v=${TAG_WITH_V}" >> $GITHUB_OUTPUT
            echo "git_tag=${GIT_TAG}" >> $GITHUB_OUTPUT
            echo "latest=${LATEST_TAG}" >> $GITHUB_OUTPUT
            echo "üè∑Ô∏è Git tag d√©tect√©: ${GIT_TAG}"
            echo "üè∑Ô∏è Image tag: ${TAG}"
            echo "üè∑Ô∏è Image tag (avec v): ${TAG_WITH_V}"
            echo "üè∑Ô∏è Latest tag: ${LATEST_TAG}"
          else
            # C'est un push sur branche - utiliser le SHA
            SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
            TAG="${{ env.REGISTRY }}/${REPO_LOWER}:main-${SHORT_SHA}"
            LATEST_TAG="${{ env.REGISTRY }}/${REPO_LOWER}:latest"
            echo "tag=${TAG}" >> $GITHUB_OUTPUT
            echo "tag_with_v=${TAG}" >> $GITHUB_OUTPUT
            echo "git_tag=main-${SHORT_SHA}" >> $GITHUB_OUTPUT
            echo "latest=${LATEST_TAG}" >> $GITHUB_OUTPUT
            echo "üè∑Ô∏è Push sur branche d√©tect√© (SHA: ${SHORT_SHA})"
            echo "üè∑Ô∏è Image tag: ${TAG}"
            echo "üè∑Ô∏è Latest tag: ${LATEST_TAG}"
          fi
      
      - name: üê≥ Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ${{ steps.image-tag.outputs.tag }}
            ${{ steps.image-tag.outputs.tag_with_v }}
            ${{ steps.image-tag.outputs.latest }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64
          build-args: |
            BUILDKIT_INLINE_CACHE=1
            GIT_TAG=${{ steps.image-tag.outputs.git_tag }}
            GIT_TAG=${{ steps.image-tag.outputs.git_tag }}

  # ============================================================================
  # Job 2: Deploy to Multiple Servers (Matrix Strategy)
  # ============================================================================
  deploy:
    name: üöÄ Deploy to ${{ matrix.server_name }}
    needs: build-and-push
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    # Strat√©gie matrix pour d√©ployer sur plusieurs serveurs
    strategy:
      fail-fast: false  # Continuer m√™me si un serveur √©choue
      matrix:
        server_name: [server1, server2]
          # Ajoutez d'autres serveurs ici : [server1, server2, server3]
    
    # Filtrer les serveurs si un serveur sp√©cifique est demand√©
    # D√©clencher sur push main, tags, ou workflow_dispatch
    # Note: La condition if avec matrix n'est pas support√©e directement, on filtre dans le job
    if: github.event.inputs.server == 'all' || github.event.inputs.server == '' || github.event_name == 'workflow_dispatch'
    
    # Utiliser l'environnement GitHub pour chaque serveur
    environment:
      name: ${{ matrix.server_name == 'server1' && 'production-cjd80' || (matrix.server_name == 'server2' && 'production-rep' || format('production-{0}', matrix.server_name)) }}
    
    # Concurrence pour √©viter les d√©ploiements simultan√©s sur le m√™me serveur
    concurrency:
      group: deploy-${{ matrix.server_name }}
      cancel-in-progress: false
    
    steps:
      - name: üîç Precheck secrets
        id: secrets-check
        env:
          SERVER_NAME: ${{ matrix.server_name }}
          # Secrets pour server1 (cjd80) - utilisent les secrets existants VPS_*
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_PORT: ${{ secrets.VPS_PORT }}
          VPS_USER: ${{ secrets.VPS_USER }}
          VPS_SSH_KEY: ${{ secrets.VPS_SSH_KEY }}
          # Secrets pour server2 (r√©seau entreprendre picardie)
          SERVER2_HOST: ${{ secrets.SERVER2_HOST }}
          SERVER2_PORT: ${{ secrets.SERVER2_PORT }}
          SERVER2_USER: ${{ secrets.SERVER2_USER }}
          SERVER2_SSH_KEY: ${{ secrets.SERVER2_SSH_KEY }}
          # Secrets pour server3 (si n√©cessaire plus tard)
          SERVER3_HOST: ${{ secrets.SERVER3_HOST }}
          SERVER3_PORT: ${{ secrets.SERVER3_PORT }}
          SERVER3_USER: ${{ secrets.SERVER3_USER }}
          SERVER3_SSH_KEY: ${{ secrets.SERVER3_SSH_KEY }}
        run: |
          set -e
          echo "üîç V√©rification des secrets pour ${SERVER_NAME}..."
          
          # D√©terminer les noms des secrets selon le serveur
          # server1 = cjd80 (utilise les secrets existants VPS_*)
          if [ "$SERVER_NAME" = "server1" ]; then
            SERVER_HOST="$VPS_HOST"
            SERVER_PORT="${VPS_PORT:-22}"
            SERVER_USER="$VPS_USER"
            SERVER_SSH_KEY="$VPS_SSH_KEY"
            SERVER_DISPLAY_NAME="CJD Amiens (cjd80.fr)"
          elif [ "$SERVER_NAME" = "server2" ]; then
            SERVER_HOST="$SERVER2_HOST"
            SERVER_PORT="${SERVER2_PORT:-22}"
            SERVER_USER="$SERVER2_USER"
            SERVER_SSH_KEY="$SERVER2_SSH_KEY"
            SERVER_DISPLAY_NAME="R√©seau Entreprendre Picardie"
          elif [ "$SERVER_NAME" = "server3" ]; then
            SERVER_HOST="$SERVER3_HOST"
            SERVER_PORT="${SERVER3_PORT:-22}"
            SERVER_USER="$SERVER3_USER"
            SERVER_SSH_KEY="$SERVER3_SSH_KEY"
            SERVER_DISPLAY_NAME="Server 3"
          else
            echo "::error::‚ùå Serveur inconnu: ${SERVER_NAME}"
            exit 1
          fi
          
          if [ -z "$SERVER_HOST" ]; then 
            if [ "$SERVER_NAME" = "server1" ]; then
              echo "::error::‚ùå Secret manquant: VPS_HOST pour ${SERVER_NAME} (CJD Amiens)"
            else
              echo "::error::‚ùå Secret manquant: SERVER${SERVER_NAME#server}_HOST pour ${SERVER_NAME}"
            fi
            exit 1
          fi
          
          if [ -z "$SERVER_USER" ]; then 
            if [ "$SERVER_NAME" = "server1" ]; then
              echo "::error::‚ùå Secret manquant: VPS_USER pour ${SERVER_NAME} (CJD Amiens)"
            else
              echo "::error::‚ùå Secret manquant: SERVER${SERVER_NAME#server}_USER pour ${SERVER_NAME}"
            fi
            exit 1
          fi
          
          if [ -z "$SERVER_SSH_KEY" ]; then 
            if [ "$SERVER_NAME" = "server1" ]; then
              echo "::error::‚ùå Secret manquant: VPS_SSH_KEY pour ${SERVER_NAME} (CJD Amiens)"
            else
              echo "::error::‚ùå Secret manquant: SERVER${SERVER_NAME#server}_SSH_KEY pour ${SERVER_NAME}"
            fi
            exit 1
          fi
          
          echo "‚úÖ Tous les secrets requis sont configur√©s pour ${SERVER_NAME} (${SERVER_DISPLAY_NAME})"
          echo "   Host: $SERVER_HOST"
          echo "   Port: ${SERVER_PORT:-22}"
          echo "   User: $SERVER_USER"
          
          # D√©terminer le dossier de d√©ploiement selon le serveur
          if [ "$SERVER_NAME" = "server1" ]; then
            DEPLOY_DIR="/docker/cjd80"
          elif [ "$SERVER_NAME" = "server2" ]; then
            DEPLOY_DIR="/home/debian/docker/apps/rep"
          else
            DEPLOY_DIR="/docker/cjd80"  # Par d√©faut
          fi
          
          # Sauvegarder les valeurs pour les √©tapes suivantes (sans les secrets)
          echo "host=$SERVER_HOST" >> $GITHUB_OUTPUT
          echo "port=${SERVER_PORT:-22}" >> $GITHUB_OUTPUT
          echo "user=$SERVER_USER" >> $GITHUB_OUTPUT
          echo "deploy_dir=$DEPLOY_DIR" >> $GITHUB_OUTPUT
          echo "display_name=$SERVER_DISPLAY_NAME" >> $GITHUB_OUTPUT
          
          # Les secrets seront utilis√©s directement via les variables d'environnement dans les √©tapes suivantes
      
      - name: üì• Checkout code
        if: steps.server-check.outputs.skip != 'true'
        uses: actions/checkout@v4
      
      - name: üîê Setup SSH
        if: steps.server-check.outputs.skip != 'true'
        env:
          SERVER_NAME: ${{ matrix.server_name }}
          # Secrets pour server1
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_PORT: ${{ secrets.VPS_PORT }}
          VPS_USER: ${{ secrets.VPS_USER }}
          VPS_SSH_KEY: ${{ secrets.VPS_SSH_KEY }}
          # Secrets pour server2
          SERVER2_HOST: ${{ secrets.SERVER2_HOST }}
          SERVER2_PORT: ${{ secrets.SERVER2_PORT }}
          SERVER2_USER: ${{ secrets.SERVER2_USER }}
          SERVER2_SSH_KEY: ${{ secrets.SERVER2_SSH_KEY }}
          # Secrets pour server3
          SERVER3_HOST: ${{ secrets.SERVER3_HOST }}
          SERVER3_PORT: ${{ secrets.SERVER3_PORT }}
          SERVER3_USER: ${{ secrets.SERVER3_USER }}
          SERVER3_SSH_KEY: ${{ secrets.SERVER3_SSH_KEY }}
          # Outputs de l'√©tape pr√©c√©dente
          SERVER_HOST: ${{ steps.secrets-check.outputs.host }}
          SERVER_PORT: ${{ steps.secrets-check.outputs.port }}
          SERVER_USER: ${{ steps.secrets-check.outputs.user }}
        run: |
          # D√©terminer les secrets selon le serveur
          if [ "$SERVER_NAME" = "server1" ]; then
            SERVER_SSH_KEY="$VPS_SSH_KEY"
          elif [ "$SERVER_NAME" = "server2" ]; then
            SERVER_SSH_KEY="$SERVER2_SSH_KEY"
          elif [ "$SERVER_NAME" = "server3" ]; then
            SERVER_SSH_KEY="$SERVER3_SSH_KEY"
          else
            echo "::error::‚ùå Serveur inconnu: ${SERVER_NAME}"
            exit 1
          fi
          
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "$SERVER_SSH_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # Ajouter le host √† known_hosts pour √©viter les prompts
          ssh-keyscan -p "$SERVER_PORT" -H "$SERVER_HOST" >> ~/.ssh/known_hosts 2>/dev/null || true
          chmod 600 ~/.ssh/known_hosts
          
          # Test de connexion SSH
          echo "üîç Test de connexion SSH..."
          if ssh -p "$SERVER_PORT" \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            -o ConnectTimeout=10 \
            -i ~/.ssh/id_rsa \
            "$SERVER_USER@$SERVER_HOST" \
            "echo 'SSH connection successful'" 2>&1; then
            echo "‚úÖ Connexion SSH r√©ussie"
          else
            echo "‚ùå ERREUR: Impossible de se connecter au serveur via SSH"
            exit 1
          fi
      
      - name: üîê Authenticate server to GHCR
        env:
          SERVER_HOST: ${{ steps.secrets-check.outputs.host }}
          SERVER_PORT: ${{ steps.secrets-check.outputs.port }}
          SERVER_USER: ${{ steps.secrets-check.outputs.user }}
        run: |
          echo "üîê Authentification de ${{ matrix.server_name }} √† GHCR..."
          MAX_RETRIES=3
          RETRY=0
          AUTH_SUCCESS=false
          
          while [ $RETRY -lt $MAX_RETRIES ]; do
            if ssh -p "$SERVER_PORT" \
              -o StrictHostKeyChecking=no \
              -o UserKnownHostsFile=/dev/null \
              -o ConnectTimeout=10 \
              -i ~/.ssh/id_rsa \
              "$SERVER_USER@$SERVER_HOST" \
              "echo '${{ secrets.GITHUB_TOKEN }}' | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin" 2>&1; then
              echo "‚úÖ Authentification GHCR r√©ussie"
              AUTH_SUCCESS=true
              break
            else
              RETRY=$((RETRY + 1))
              if [ $RETRY -lt $MAX_RETRIES ]; then
                echo "‚ö†Ô∏è  √âchec de l'authentification (tentative $RETRY/$MAX_RETRIES), nouvelle tentative dans 2s..."
                sleep 2
              fi
            fi
          done
          
          if [ "$AUTH_SUCCESS" = false ]; then
            echo "‚ö†Ô∏è  Authentification GHCR √©chou√©e apr√®s $MAX_RETRIES tentatives, mais on continue..."
            echo "   L'image peut d√©j√† √™tre en cache ou accessible publiquement"
          fi
      
      - name: üì¶ Prepare server directories
        env:
          SERVER_HOST: ${{ steps.secrets-check.outputs.host }}
          SERVER_PORT: ${{ steps.secrets-check.outputs.port }}
          SERVER_USER: ${{ steps.secrets-check.outputs.user }}
          DEPLOY_DIR: ${{ steps.secrets-check.outputs.deploy_dir }}
        run: |
          ssh -p "$SERVER_PORT" \
            -i ~/.ssh/id_rsa \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            -o ConnectTimeout=10 \
            "$SERVER_USER@$SERVER_HOST" \
            'bash -s' << ENDSSH
          set -e
          
          mkdir -p "$DEPLOY_DIR/scripts"
          
          # Cloner ou mettre √† jour le repository
          if [ ! -d "$DEPLOY_DIR/.git" ]; then
            echo "üì¶ Clonage initial du repository..."
            cd "$DEPLOY_DIR"
            git init
            git remote add origin https://github.com/${{ github.repository }}.git || true
            git fetch origin main
            git reset --hard origin/main
          else
            echo "üîÑ Mise √† jour du repository..."
            cd "$DEPLOY_DIR"
            git fetch origin main
            git reset --hard origin/main
          fi
          
          # V√©rifier que .env existe
          if [ ! -f "$DEPLOY_DIR/.env" ]; then
            echo "‚ö†Ô∏è  ATTENTION: Le fichier .env n'existe pas encore!"
            echo "   Vous devez le cr√©er √† partir de .env.example"
          fi
          
          # Rendre les scripts ex√©cutables
          chmod +x "$DEPLOY_DIR/scripts/"*.sh 2>/dev/null || true
          
          echo "‚úÖ Pr√©paration du serveur termin√©e"
          ENDSSH
      
      - name: üöÄ Deploy to server
        env:
          IMAGE_TAG: ${{ needs.build-and-push.outputs.image_tag }}
          IMAGE_LATEST: ${{ needs.build-and-push.outputs.image_latest }}
          SERVER_HOST: ${{ steps.secrets-check.outputs.host }}
          SERVER_PORT: ${{ steps.secrets-check.outputs.port }}
          SERVER_USER: ${{ steps.secrets-check.outputs.user }}
          DEPLOY_DIR: ${{ steps.secrets-check.outputs.deploy_dir }}
        run: |
          ssh -p "$SERVER_PORT" \
            -i ~/.ssh/id_rsa \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            -o ConnectTimeout=10 \
            "$SERVER_USER@$SERVER_HOST" \
            'bash -s' << ENDSSH
          set -e
          
          echo "üöÄ D√©ploiement de l'image: ${IMAGE_TAG}"
          
          cd "$DEPLOY_DIR"
          
          # V√©rifier que le dossier existe
          if [ ! -d "$DEPLOY_DIR" ]; then
            echo "‚ùå ERREUR: Le dossier de d√©ploiement n'existe pas: $DEPLOY_DIR"
            exit 1
          fi
          
          # Mise √† jour du repository avec retry
          echo "üîÑ Mise √† jour du repository..."
          MAX_RETRIES=3
          RETRY=0
          while [ $RETRY -lt $MAX_RETRIES ]; do
            if git fetch origin main && git pull --ff-only origin main; then
              echo "‚úÖ Repository mis √† jour avec succ√®s"
              break
            else
              RETRY=$((RETRY + 1))
              if [ $RETRY -lt $MAX_RETRIES ]; then
                echo "‚ö†Ô∏è  √âchec de la mise √† jour (tentative $RETRY/$MAX_RETRIES), nouvelle tentative dans 2s..."
                sleep 2
              else
                echo "‚ö†Ô∏è  Fast-forward impossible apr√®s $MAX_RETRIES tentatives, utilisation de la version pr√©par√©e"
              fi
            fi
          done
          
          # V√©rifier que les scripts existent
          if [ ! -f "scripts/vps-deploy.sh" ]; then
            echo "‚ùå ERREUR: Le script scripts/vps-deploy.sh n'existe pas"
            exit 1
          fi
          
          # Rendre les scripts ex√©cutables
          chmod +x scripts/*.sh 2>/dev/null || true
          
          # Pull de l'image depuis GHCR avec retry
          echo "‚¨áÔ∏è  T√©l√©chargement de l'image depuis GHCR..."
          MAX_RETRIES=3
          RETRY=0
          while [ $RETRY -lt $MAX_RETRIES ]; do
            if docker pull "${IMAGE_TAG}"; then
              echo "‚úÖ Image t√©l√©charg√©e avec succ√®s"
              break
            else
              RETRY=$((RETRY + 1))
              if [ $RETRY -lt $MAX_RETRIES ]; then
                echo "‚ö†Ô∏è  √âchec du t√©l√©chargement (tentative $RETRY/$MAX_RETRIES), nouvelle tentative dans 5s..."
                sleep 5
              else
                echo "‚ùå ERREUR: Impossible de t√©l√©charger l'image ${IMAGE_TAG} apr√®s $MAX_RETRIES tentatives"
                exit 1
              fi
            fi
          done
          
          # Tag comme latest localement (extraire le repository sans le tag)
          REPO_NAME=$(echo "${IMAGE_TAG}" | cut -d: -f1)
          docker tag "${IMAGE_TAG}" "${REPO_NAME}:latest" || true
          
          # Exporter l'image tag pour docker-compose
          export DOCKER_IMAGE="${IMAGE_TAG}"
          
          # Ex√©cuter le script de d√©ploiement
          echo "üîÑ Ex√©cution du script de d√©ploiement..."
          if ! bash scripts/vps-deploy.sh; then
            echo "‚ùå ERREUR: Le script de d√©ploiement a √©chou√©"
            echo "üìã Logs du script:"
            exit 1
          fi
          ENDSSH
      
      - name: üîç Verify deployment health
        env:
          SERVER_HOST: ${{ steps.secrets-check.outputs.host }}
          SERVER_PORT: ${{ steps.secrets-check.outputs.port }}
          SERVER_USER: ${{ steps.secrets-check.outputs.user }}
          DEPLOY_DIR: ${{ steps.secrets-check.outputs.deploy_dir }}
          SERVER_NAME: ${{ matrix.server_name }}
          DISPLAY_NAME: ${{ steps.secrets-check.outputs.display_name }}
        run: |
          ssh -p "$SERVER_PORT" \
            -i ~/.ssh/id_rsa \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            -o ConnectTimeout=10 \
            "$SERVER_USER@$SERVER_HOST" \
            'bash -s' << ENDSSH
          set -e
          
          cd "$DEPLOY_DIR"
          echo "üîç V√©rification du d√©ploiement sur ${SERVER_NAME} (${DISPLAY_NAME})..."
          
          MAX_ATTEMPTS=30
          ATTEMPT=0
          HEALTH_CHECK_PASSED=false
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            
            # V√©rifier que le conteneur est en cours d'ex√©cution
            if ! docker compose ps | grep -q "cjd-app.*Up"; then
              echo "‚ö†Ô∏è  Le conteneur n'est pas en cours d'ex√©cution"
              docker compose ps
              sleep 2
              continue
            fi
            
            # V√©rifier le health check depuis le conteneur
            if docker compose exec -T cjd-app wget --spider -q http://localhost:5000/api/health 2>/dev/null; then
              echo "‚úÖ Health check r√©ussi depuis le conteneur!"
              HEALTH_CHECK_PASSED=true
              break
            fi
            
            # Alternative: v√©rifier via curl depuis le serveur
            if command -v curl >/dev/null 2>&1 && curl -f -s -o /dev/null http://localhost:5000/api/health 2>/dev/null; then
              echo "‚úÖ Health check r√©ussi via curl!"
              HEALTH_CHECK_PASSED=true
              break
            fi
            
            # Calculer le d√©lai avec backoff exponentiel (min 2s, max 10s)
            DELAY=$((2 * ATTEMPT))
            if [ $DELAY -gt 10 ]; then
              DELAY=10
            fi
            
            echo "‚è≥ Tentative $ATTEMPT/$MAX_ATTEMPTS: En attente de la r√©ponse (${DELAY}s)..."
            sleep $DELAY
          done
          
          if [ "$HEALTH_CHECK_PASSED" = true ]; then
            echo "‚úÖ D√©ploiement r√©ussi sur ${SERVER_NAME}!"
            echo "üìä Statut du conteneur:"
            docker compose ps
            echo ""
            echo "üìã R√©ponse du health check:"
            docker compose exec -T cjd-app wget -q -O- http://localhost:5000/api/health || curl -s http://localhost:5000/api/health
            exit 0
          else
            echo "‚ùå Le health check a √©chou√© apr√®s $((MAX_ATTEMPTS * 2)) secondes"
            echo "üìã Logs du conteneur (derni√®res 50 lignes):"
            docker compose logs --tail=50 cjd-app
            echo ""
            echo "üìä Statut du conteneur:"
            docker compose ps
            exit 1
          fi
          ENDSSH
      
      - name: üßπ Cleanup old images
        if: success()
        env:
          SERVER_HOST: ${{ steps.secrets-check.outputs.host }}
          SERVER_PORT: ${{ steps.secrets-check.outputs.port }}
          SERVER_USER: ${{ steps.secrets-check.outputs.user }}
          DEPLOY_DIR: ${{ steps.secrets-check.outputs.deploy_dir }}
          SERVER_NAME: ${{ matrix.server_name }}
          DISPLAY_NAME: ${{ steps.secrets-check.outputs.display_name }}
        run: |
          ssh -p "$SERVER_PORT" \
            -i ~/.ssh/id_rsa \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            -o ConnectTimeout=10 \
            "$SERVER_USER@$SERVER_HOST" \
            'bash -s' << ENDSSH
          echo "üßπ Nettoyage des anciennes images Docker sur ${SERVER_NAME} (${DISPLAY_NAME})..."
          
          # Nettoyer les images non utilis√©es (plus de 24h)
          docker image prune -f --filter "until=24h" || true
          
          # Nettoyer les conteneurs arr√™t√©s
          docker container prune -f || true
          
          # Afficher l'espace lib√©r√©
          echo "üìä Espace disque apr√®s nettoyage:"
          df -h "$DEPLOY_DIR" | tail -1 || true
          
          echo '‚úÖ Nettoyage termin√©'
          ENDSSH
      
      - name: üìä Deployment summary
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "üéâ ‚úÖ D√©ploiement r√©ussi sur ${{ matrix.server_name }}"
            echo "üì¶ Image: ${{ needs.build-and-push.outputs.image_tag }}"
          else
            echo "‚ùå √âchec du d√©ploiement sur ${{ matrix.server_name }}"
            echo "üìã V√©rifiez les logs ci-dessus pour plus de d√©tails"
          fi

  # ============================================================================
  # Job 3: Deployment Summary (optionnel)
  # ============================================================================
  deployment-summary:
    name: üìä Deployment Summary
    needs: [build-and-push, deploy]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: üìä Summary
        run: |
          echo "## üöÄ R√©sum√© du d√©ploiement" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Image Docker:** \`${{ needs.build-and-push.outputs.image_tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Digest:** \`${{ needs.build-and-push.outputs.image_digest }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üì¶ Serveurs d√©ploy√©s" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "‚úÖ Tous les serveurs ont √©t√© d√©ploy√©s avec succ√®s" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ö†Ô∏è Certains serveurs ont √©chou√©. V√©rifiez les logs ci-dessus." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Auteur:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          if [ -n "${{ github.ref }}" ] && echo "${{ github.ref }}" | grep -q "refs/tags/"; then
            GIT_TAG=$(echo "${{ github.ref }}" | sed 's/refs\/tags\///')
            echo "**Tag:** \`${GIT_TAG}\`" >> $GITHUB_STEP_SUMMARY
          fi
          if [ -n "${{ github.event.head_commit.message }}" ]; then
            echo "**Message:** ${{ github.event.head_commit.message }}" >> $GITHUB_STEP_SUMMARY
          fi

