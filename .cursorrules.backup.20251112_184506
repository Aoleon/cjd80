# Règles Cursor pour CJD Amiens - Boîte à Kiffs

## Conventions de code

### TypeScript
- TypeScript strict activé
- Toujours typer les fonctions et variables
- Utiliser les types depuis `@shared/schema` pour la cohérence
- Préférer les interfaces pour les props de composants

### React / Frontend
- Composants fonctionnels avec hooks uniquement
- Structure standardisée des composants :
  1. Hooks d'état (useState)
  2. Hooks de données (useQuery)
  3. Mutations (useMutation)
  4. Handlers
  5. Render (return)
- Utiliser TanStack Query pour toutes les requêtes API
- Utiliser les composants shadcn/ui depuis `@/components/ui`
- Classes Tailwind avec préfixe sémantique : `text-cjd-green`, `bg-success`, etc.

### Backend / API
- Toutes les routes dans `server/routes.ts`
- Utiliser les schémas Zod pour la validation
- Retourner toujours `Result<T>` depuis `storage.ts`
- Gérer les erreurs avec `ApiError` depuis `@shared/errors`
- Logger avec `logger` depuis `server/lib/logger`

### Structure des réponses API
- Format standard : `{ success: boolean, data?: T, error?: Error }`
- Endpoints paginés : `{ success: boolean, data: { data: T[], total: number, page: number, limit: number } }`

### Base de données
- Utiliser Drizzle ORM
- Schémas dans `shared/schema.ts`
- Utiliser `runDbQuery` avec profils ('quick', 'normal', 'slow')
- Toujours gérer les erreurs de connexion avec résilience

### Sécurité
- Jamais de secrets hardcodés
- Validation stricte des entrées avec Zod
- Sanitisation des textes utilisateur
- Rate limiting sur les endpoints publics

### Nommage
- Composants : PascalCase (`LoanItemTable.tsx`)
- Fichiers : kebab-case pour les utilitaires (`admin-utils.ts`)
- Hooks : camelCase avec préfixe `use` (`useAdminLoanItems.ts`)
- Types : PascalCase (`LoanItem`, `InsertLoanItem`)

### Imports
- Utiliser les alias `@/` pour les imports client
- Utiliser `@shared/` pour les imports partagés
- Grouper les imports : React, librairies externes, composants locaux, types

### Messages de commit
- Format : `<type>: <description>`
- Types : `feat`, `fix`, `docs`, `refactor`, `chore`
- Toujours en français pour ce projet

### Fichiers à ne jamais modifier
- `package-lock.json` (sauf `npm install`)
- `.env` (utiliser `.env.example` comme référence)
- Fichiers générés automatiquement

### Bonnes pratiques spécifiques
- Toujours vérifier `result.success` avant d'utiliser `result.data`
- Utiliser `toast` pour les notifications utilisateur
- Gérer les états de chargement avec `isLoading` de React Query
- Invalider les queries après mutations : `queryClient.invalidateQueries`
- Utiliser les composants UI de shadcn/ui, ne pas créer de composants UI custom

### Gestion des erreurs
- Frontend : Afficher des messages d'erreur clairs avec `toast`
- Backend : Logger les erreurs avec contexte complet
- API : Retourner des codes HTTP appropriés (400, 404, 500)
- Ne jamais exposer les détails d'erreur en production

### Performance
- Utiliser React.memo pour les composants lourds
- Lazy loading des routes si nécessaire
- Pagination pour les listes longues
- Cache React Query : 5 minutes par défaut

### Tests
- Tests E2E avec Playwright dans `tests/e2e/`
- Tester les workflows complets, pas seulement les composants isolés

### Documentation
- Commenter les fonctions complexes
- Documenter les types complexes avec JSDoc
- Mettre à jour le README pour les nouvelles fonctionnalités

